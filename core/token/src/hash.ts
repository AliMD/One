import {createHash, randomBytes, type BinaryLike} from 'node:crypto';

import type {HashGeneratorConfig} from './type.js';

/**
 * Secure **self-validate** hash generator.
 */
export class AlwatrHashGenerator {
  constructor(public config: HashGeneratorConfig) {}

  /**
   * Generate simple hash from random data.
   *
   * Example:
   *
   * ```js
   * const clientId = hashGenerator.random();
   * ```
   */
  random(size: number = this.config.mainSize): string {
    return this.generate(randomBytes(size), size);
  }

  /**
   * Generate **self-validate** hash from random data.
   *
   * Example:
   *
   * ```ts
   * const userId = hashGenerator.randomSelfValidate();
   * ```
   */
  randomSelfValidate(size: number = this.config.mainSize): string {
    return this.generateSelfValidate(randomBytes(size), size);
  }

  /**
   * Generate simple hash from data.
   *
   * Example:
   *
   * ```ts
   * const crcHash = hashGenerator.generate(downloadedData);
   * ```
   */
  generate(data: BinaryLike, size: number = this.config.mainSize): string {
    return createHash(this.config.algorithm, {outputLength: size})
        .update(data)
        .digest(this.config.encoding);
  }

  /**
   * Generate **self-validate** hash from data.
   *
   * Example:
   *
   * ```js
   * const userId = hashGenerator.generateSelfValidate(randomData);
   * ```
   */
  generateSelfValidate(data: BinaryLike): string {
    const mainHash = this.generate(data, this.config.mainSize);
    const crcHash = this.generate(mainHash, this.config.crcSize);
    return mainHash + crcHash;
  }

  /**
   * Verify `generate(data)` equals to `hash`.
   *
   * Example:
   *
   * ```ts
   * if (!hashGenerator.verify(downloadedData, crcHash)) {
   *   new Error('data_corrupted');
   * }
   * ```
   */
  verify(data: BinaryLike, hash: string): boolean {
    return hash === this.generate(data);
  }

  /**
   * Verify a **self-validate** hash to check its generated by this class (same options).
   *
   * Example:
   *
   * ```ts
   * if (!hashGenerator.verifySelfValidate(user.id)) {
   *   new Error('invalid_user');
   * }
   * ```
   */
  verifySelfValidate(hash: string): boolean {
    const crcLen = this.generate('', this.config.crcSize).length;
    const part1 = hash.substring(0, hash.length - crcLen);
    const part2 = hash.substring(hash.length - crcLen, hash.length);
    return this.verify(part1, part2);
  }
}
